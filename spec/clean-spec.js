// Generated by CoffeeScript 1.12.7
(function() {
  var apm, express, fs, http, path, temp, wrench;

  path = require('path');

  fs = require('fs-plus');

  temp = require('temp');

  express = require('express');

  http = require('http');

  wrench = require('wrench');

  apm = require('../lib/apm-cli');

  describe('apm clean', function() {
    var moduleDirectory, ref, server;
    ref = [], moduleDirectory = ref[0], server = ref[1];
    beforeEach(function() {
      var app, live;
      silenceOutput();
      spyOnToken();
      app = express();
      app.get('/node/v10.20.1/node-v10.20.1.tar.gz', function(request, response) {
        return response.sendFile(path.join(__dirname, 'fixtures', 'node-v10.20.1.tar.gz'));
      });
      app.get('/node/v10.20.1/node-v10.20.1-headers.tar.gz', function(request, response) {
        return response.sendFile(path.join(__dirname, 'fixtures', 'node-v10.20.1-headers.tar.gz'));
      });
      app.get('/node/v10.20.1/node.lib', function(request, response) {
        return response.sendFile(path.join(__dirname, 'fixtures', 'node.lib'));
      });
      app.get('/node/v10.20.1/x64/node.lib', function(request, response) {
        return response.sendFile(path.join(__dirname, 'fixtures', 'node_x64.lib'));
      });
      app.get('/node/v10.20.1/SHASUMS256.txt', function(request, response) {
        return response.sendFile(path.join(__dirname, 'fixtures', 'SHASUMS256.txt'));
      });
      app.get('/test-module', function(request, response) {
        return response.sendFile(path.join(__dirname, 'fixtures', 'install-test-module.json'));
      });
      app.get('/tarball/test-module-1.2.0.tgz', function(request, response) {
        return response.sendFile(path.join(__dirname, 'fixtures', 'test-module-1.2.0.tgz'));
      });
      server = http.createServer(app);
      live = false;
      server.listen(3000, '127.0.0.1', function() {
        var atomHome;
        console.log("Server started");
        atomHome = temp.mkdirSync('apm-home-dir-');
        process.env.ATOM_HOME = atomHome;
        process.env.ATOM_ELECTRON_URL = "http://localhost:3000/node";
        process.env.ATOM_ELECTRON_VERSION = 'v10.20.1';
        process.env.npm_config_registry = 'http://localhost:3000/';
        moduleDirectory = path.join(temp.mkdirSync('apm-test-module-'), 'test-module-with-dependencies');
        wrench.copyDirSyncRecursive(path.join(__dirname, 'fixtures', 'test-module-with-dependencies'), moduleDirectory);
        process.chdir(moduleDirectory);
        return live = true;
      });
      return waitsFor(function() {
        return live;
      });
    });
    afterEach(function() {
      var done;
      done = false;
      server.close(function() {
        return done = true;
      });
      return waitsFor(function() {
        return done;
      });
    });
    it('uninstalls any packages not referenced in the package.json', function() {
      var callback, removedPath;
      removedPath = path.join(moduleDirectory, 'node_modules', 'will-be-removed');
      fs.makeTreeSync(removedPath);
      fs.writeFileSync(path.join(removedPath, 'package.json'), '{"name": "will-be-removed", "version": "1.0.0", "dependencies": {}}', 'utf8');
      callback = jasmine.createSpy('callback');
      apm.run(['clean'], callback);
      waitsFor('waiting for command to complete', function() {
        return callback.callCount > 0;
      });
      return runs(function() {
        expect(callback.mostRecentCall.args[0]).toBeUndefined();
        return expect(fs.existsSync(removedPath)).toBeFalsy();
      });
    });
    return it('uninstalls a scoped package', function() {
      var callback, removedPath;
      removedPath = path.join(moduleDirectory, 'node_modules/@types/atom');
      fs.makeTreeSync(removedPath);
      fs.writeFileSync(path.join(removedPath, 'package.json'), '{"name": "@types/atom", "version": "1.0.0", "dependencies": {}}', 'utf8');
      callback = jasmine.createSpy('callback');
      apm.run(['clean'], callback);
      waitsFor('waiting for command to complete', function() {
        return callback.callCount > 0;
      });
      return runs(function() {
        expect(callback.mostRecentCall.args[0]).toBeUndefined();
        return expect(fs.existsSync(removedPath)).toBeFalsy();
      });
    });
  });

}).call(this);
