// Generated by CoffeeScript 1.12.7
(function() {
  var apm, createPackage, fs, path, temp;

  path = require('path');

  fs = require('fs-plus');

  temp = require('temp');

  apm = require('../lib/apm-cli');

  createPackage = function(packageName, includeDev) {
    var atomHome, devPackagePath, packagePath;
    if (includeDev == null) {
      includeDev = false;
    }
    atomHome = temp.mkdirSync('apm-home-dir-');
    packagePath = path.join(atomHome, 'packages', packageName);
    fs.makeTreeSync(path.join(packagePath, 'lib'));
    fs.writeFileSync(path.join(packagePath, 'package.json'), "{}");
    if (includeDev) {
      devPackagePath = path.join(atomHome, 'dev', 'packages', packageName);
      fs.makeTreeSync(path.join(devPackagePath, 'lib'));
      fs.writeFileSync(path.join(devPackagePath, 'package.json'), "{}");
    }
    process.env.ATOM_HOME = atomHome;
    return {
      packagePath: packagePath,
      devPackagePath: devPackagePath
    };
  };

  describe('apm uninstall', function() {
    beforeEach(function() {
      silenceOutput();
      spyOnToken();
      return process.env.ATOM_API_URL = 'http://localhost:5432';
    });
    describe('when no package is specified', function() {
      return it('logs an error and exits', function() {
        var callback;
        callback = jasmine.createSpy('callback');
        apm.run(['uninstall'], callback);
        waitsFor('waiting for command to complete', function() {
          return callback.callCount > 0;
        });
        return runs(function() {
          expect(console.error.mostRecentCall.args[0].length).toBeGreaterThan(0);
          return expect(callback.mostRecentCall.args[0]).not.toBeUndefined();
        });
      });
    });
    describe('when the package is not installed', function() {
      return it('ignores the package', function() {
        var callback;
        callback = jasmine.createSpy('callback');
        apm.run(['uninstall', 'a-package-that-does-not-exist'], callback);
        waitsFor('waiting for command to complete', function() {
          return callback.callCount > 0;
        });
        return runs(function() {
          return expect(console.error.callCount).toBe(1);
        });
      });
    });
    describe('when the package is installed', function() {
      return it('deletes the package', function() {
        var callback, packagePath;
        packagePath = createPackage('test-package').packagePath;
        expect(fs.existsSync(packagePath)).toBeTruthy();
        callback = jasmine.createSpy('callback');
        apm.run(['uninstall', 'test-package'], callback);
        waitsFor('waiting for command to complete', function() {
          return callback.callCount > 0;
        });
        return runs(function() {
          return expect(fs.existsSync(packagePath)).toBeFalsy();
        });
      });
    });
    return describe('when the package folder exists but does not contain a package.json', function() {
      it('does not delete the folder', function() {
        var callback, packagePath;
        packagePath = createPackage('test-package').packagePath;
        fs.unlinkSync(path.join(packagePath, 'package.json'));
        callback = jasmine.createSpy('callback');
        apm.run(['uninstall', 'test-package'], callback);
        waitsFor('waiting for command to complete', function() {
          return callback.callCount > 0;
        });
        return runs(function() {
          return expect(fs.existsSync(packagePath)).toBeTruthy();
        });
      });
      describe('when . is specified as the package name', function() {
        return it('resolves to the basename of the cwd', function() {
          var callback, oldCwd, packagePath;
          packagePath = createPackage('test-package').packagePath;
          expect(fs.existsSync(packagePath)).toBeTruthy();
          oldCwd = process.cwd();
          process.chdir(packagePath);
          callback = jasmine.createSpy('callback');
          apm.run(['uninstall', '.'], callback);
          waitsFor('waiting for command to complete', function() {
            return callback.callCount > 0;
          });
          return runs(function() {
            expect(fs.existsSync(packagePath)).toBeFalsy();
            return process.chdir(oldCwd);
          });
        });
      });
      describe("--dev", function() {
        return it("deletes the packages from the dev packages folder", function() {
          var callback, devPackagePath, packagePath, ref;
          ref = createPackage('test-package', true), packagePath = ref.packagePath, devPackagePath = ref.devPackagePath;
          expect(fs.existsSync(packagePath)).toBeTruthy();
          callback = jasmine.createSpy('callback');
          apm.run(['uninstall', 'test-package', '--dev'], callback);
          waitsFor('waiting for command to complete', function() {
            return callback.callCount > 0;
          });
          return runs(function() {
            expect(fs.existsSync(devPackagePath)).toBeFalsy();
            return expect(fs.existsSync(packagePath)).toBeTruthy();
          });
        });
      });
      return describe("--hard", function() {
        return it("deletes the packages from the both packages folders", function() {
          var atomHome, callback, devPackagePath, packagePath;
          atomHome = temp.mkdirSync('apm-home-dir-');
          packagePath = path.join(atomHome, 'packages', 'test-package');
          fs.makeTreeSync(path.join(packagePath, 'lib'));
          fs.writeFileSync(path.join(packagePath, 'package.json'), "{}");
          devPackagePath = path.join(atomHome, 'dev', 'packages', 'test-package');
          fs.makeTreeSync(path.join(devPackagePath, 'lib'));
          fs.writeFileSync(path.join(devPackagePath, 'package.json'), "{}");
          process.env.ATOM_HOME = atomHome;
          expect(fs.existsSync(packagePath)).toBeTruthy();
          callback = jasmine.createSpy('callback');
          apm.run(['uninstall', 'test-package', '--hard'], callback);
          waitsFor('waiting for command to complete', function() {
            return callback.callCount > 0;
          });
          return runs(function() {
            expect(fs.existsSync(devPackagePath)).toBeFalsy();
            return expect(fs.existsSync(packagePath)).toBeFalsy();
          });
        });
      });
    });
  });

}).call(this);
