// Generated by CoffeeScript 1.12.7
(function() {
  var apm, express, fs, http, path, temp;

  path = require('path');

  fs = require('fs-plus');

  temp = require('temp');

  express = require('express');

  http = require('http');

  apm = require('../lib/apm-cli');

  describe('apm publish', function() {
    var server;
    server = [][0];
    beforeEach(function() {
      var app, live;
      spyOnToken();
      silenceOutput();
      app = express();
      server = http.createServer(app);
      live = false;
      server.listen(3000, '127.0.0.1', function() {
        var atomHome;
        atomHome = temp.mkdirSync('apm-home-dir-');
        process.env.ATOM_HOME = atomHome;
        process.env.ATOM_API_URL = "http://localhost:3000/api";
        process.env.ATOM_RESOURCE_PATH = temp.mkdirSync('atom-resource-path-');
        return live = true;
      });
      return waitsFor(function() {
        return live;
      });
    });
    afterEach(function() {
      var done;
      done = false;
      server.close(function() {
        return done = true;
      });
      return waitsFor(function() {
        return done;
      });
    });
    it("validates the package's package.json file", function() {
      var callback, packageToPublish;
      packageToPublish = temp.mkdirSync('apm-test-package-');
      fs.writeFileSync(path.join(packageToPublish, 'package.json'), '}{');
      process.chdir(packageToPublish);
      callback = jasmine.createSpy('callback');
      apm.run(['publish'], callback);
      waitsFor('waiting for publish to complete', 600000, function() {
        return callback.callCount === 1;
      });
      return runs(function() {
        return expect(callback.mostRecentCall.args[0].message).toBe('Error parsing package.json file: Unexpected token } in JSON at position 0');
      });
    });
    it("validates the package is in a Git repository", function() {
      var callback, metadata, packageToPublish;
      packageToPublish = temp.mkdirSync('apm-test-package-');
      metadata = {
        name: 'test',
        version: '1.0.0'
      };
      fs.writeFileSync(path.join(packageToPublish, 'package.json'), JSON.stringify(metadata));
      process.chdir(packageToPublish);
      callback = jasmine.createSpy('callback');
      apm.run(['publish'], callback);
      waitsFor('waiting for publish to complete', 600000, function() {
        return callback.callCount === 1;
      });
      return runs(function() {
        return expect(callback.mostRecentCall.args[0].message).toBe('Package must be in a Git repository before publishing: https://help.github.com/articles/create-a-repo');
      });
    });
    it("validates the engines.atom range in the package.json file", function() {
      var callback, metadata, packageToPublish;
      packageToPublish = temp.mkdirSync('apm-test-package-');
      metadata = {
        name: 'test',
        version: '1.0.0',
        engines: {
          atom: '><>'
        }
      };
      fs.writeFileSync(path.join(packageToPublish, 'package.json'), JSON.stringify(metadata));
      process.chdir(packageToPublish);
      callback = jasmine.createSpy('callback');
      apm.run(['publish'], callback);
      waitsFor('waiting for publish to complete', 600000, function() {
        return callback.callCount === 1;
      });
      return runs(function() {
        return expect(callback.mostRecentCall.args[0].message).toBe('The Pulsar or Atom engine range in the package.json file is invalid: ><>');
      });
    });
    it("validates the dependency semver ranges in the package.json file", function() {
      var callback, metadata, packageToPublish;
      packageToPublish = temp.mkdirSync('apm-test-package-');
      metadata = {
        name: 'test',
        version: '1.0.0',
        engines: {
          atom: '1'
        },
        dependencies: {
          abc: 'git://github.com/user/project.git',
          abcd: 'latest',
          foo: '^^'
        }
      };
      fs.writeFileSync(path.join(packageToPublish, 'package.json'), JSON.stringify(metadata));
      process.chdir(packageToPublish);
      callback = jasmine.createSpy('callback');
      apm.run(['publish'], callback);
      waitsFor('waiting for publish to complete', 600000, function() {
        return callback.callCount === 1;
      });
      return runs(function() {
        return expect(callback.mostRecentCall.args[0].message).toBe('The foo dependency range in the package.json file is invalid: ^^');
      });
    });
    return it("validates the dev dependency semver ranges in the package.json file", function() {
      var callback, metadata, packageToPublish;
      packageToPublish = temp.mkdirSync('apm-test-package-');
      metadata = {
        name: 'test',
        version: '1.0.0',
        engines: {
          atom: '1'
        },
        dependencies: {
          foo: '^5'
        },
        devDependencies: {
          abc: 'git://github.com/user/project.git',
          abcd: 'latest',
          bar: '1,3'
        }
      };
      fs.writeFileSync(path.join(packageToPublish, 'package.json'), JSON.stringify(metadata));
      process.chdir(packageToPublish);
      callback = jasmine.createSpy('callback');
      apm.run(['publish'], callback);
      waitsFor('waiting for publish to complete', 600000, function() {
        return callback.callCount === 1;
      });
      return runs(function() {
        return expect(callback.mostRecentCall.args[0].message).toBe('The bar dev dependency range in the package.json file is invalid: 1,3');
      });
    });
  });

}).call(this);
