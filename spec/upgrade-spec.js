// Generated by CoffeeScript 1.12.7
(function() {
  var apm, apmRun, express, fs, http, path, temp, wrench;

  path = require('path');

  fs = require('fs-plus');

  temp = require('temp');

  express = require('express');

  http = require('http');

  wrench = require('wrench');

  apm = require('../lib/apm-cli');

  apmRun = function(args, callback) {
    var ran;
    ran = false;
    apm.run(args, function() {
      return ran = true;
    });
    waitsFor("waiting for apm " + (args.join(' ')), 60000, function() {
      return ran;
    });
    return runs(callback);
  };

  describe("apm upgrade", function() {
    var atomApp, atomHome, packagesDir, ref, server;
    ref = [], atomApp = ref[0], atomHome = ref[1], packagesDir = ref[2], server = ref[3];
    beforeEach(function() {
      var app, live;
      spyOnToken();
      silenceOutput();
      atomHome = temp.mkdirSync('apm-home-dir-');
      process.env.ATOM_HOME = atomHome;
      app = express();
      app.get('/packages/test-module', function(request, response) {
        return response.sendFile(path.join(__dirname, 'fixtures', 'upgrade-test-module.json'));
      });
      app.get('/packages/multi-module', function(request, response) {
        return response.sendFile(path.join(__dirname, 'fixtures', 'upgrade-multi-version.json'));
      });
      app.get('/packages/different-repo', function(request, response) {
        return response.sendFile(path.join(__dirname, 'fixtures', 'upgrade-different-repo.json'));
      });
      server = http.createServer(app);
      live = false;
      server.listen(3000, '127.0.0.1', function() {
        atomHome = temp.mkdirSync('apm-home-dir-');
        atomApp = temp.mkdirSync('apm-app-dir-');
        packagesDir = path.join(atomHome, 'packages');
        process.env.ATOM_HOME = atomHome;
        process.env.ATOM_ELECTRON_URL = "http://localhost:3000/node";
        process.env.ATOM_PACKAGES_URL = "http://localhost:3000/packages";
        process.env.ATOM_ELECTRON_VERSION = 'v10.20.1';
        process.env.ATOM_RESOURCE_PATH = atomApp;
        fs.writeFileSync(path.join(atomApp, 'package.json'), JSON.stringify({
          version: '0.10.0'
        }));
        return live = true;
      });
      return waitsFor(function() {
        return live;
      });
    });
    afterEach(function() {
      var done;
      done = false;
      server.close(function() {
        return done = true;
      });
      return waitsFor(function() {
        return done;
      });
    });
    it("does not display updates for unpublished packages", function() {
      var callback;
      fs.writeFileSync(path.join(packagesDir, 'not-published', 'package.json'), JSON.stringify({
        name: 'not-published',
        version: '1.0',
        repository: 'https://github.com/a/b'
      }));
      callback = jasmine.createSpy('callback');
      apm.run(['upgrade', '--list', '--no-color'], callback);
      waitsFor('waiting for upgrade to complete', 600000, function() {
        return callback.callCount > 0;
      });
      return runs(function() {
        expect(console.log).toHaveBeenCalled();
        return expect(console.log.argsForCall[1][0]).toContain('empty');
      });
    });
    it("does not display updates for packages whose engine does not satisfy the installed Atom version", function() {
      var callback;
      fs.writeFileSync(path.join(packagesDir, 'test-module', 'package.json'), JSON.stringify({
        name: 'test-module',
        version: '0.3.0',
        repository: 'https://github.com/a/b'
      }));
      callback = jasmine.createSpy('callback');
      apm.run(['upgrade', '--list', '--no-color'], callback);
      waitsFor('waiting for upgrade to complete', 600000, function() {
        return callback.callCount > 0;
      });
      return runs(function() {
        expect(console.log).toHaveBeenCalled();
        return expect(console.log.argsForCall[1][0]).toContain('empty');
      });
    });
    it("displays the latest update that satisfies the installed Atom version", function() {
      var callback;
      fs.writeFileSync(path.join(packagesDir, 'multi-module', 'package.json'), JSON.stringify({
        name: 'multi-module',
        version: '0.1.0',
        repository: 'https://github.com/a/b'
      }));
      callback = jasmine.createSpy('callback');
      apm.run(['upgrade', '--list', '--no-color'], callback);
      waitsFor('waiting for upgrade to complete', 600000, function() {
        return callback.callCount > 0;
      });
      return runs(function() {
        expect(console.log).toHaveBeenCalled();
        return expect(console.log.argsForCall[1][0]).toContain('multi-module 0.1.0 -> 0.3.0');
      });
    });
    it("does not display updates for packages already up to date", function() {
      var callback;
      fs.writeFileSync(path.join(packagesDir, 'multi-module', 'package.json'), JSON.stringify({
        name: 'multi-module',
        version: '0.3.0',
        repository: 'https://github.com/a/b'
      }));
      callback = jasmine.createSpy('callback');
      apm.run(['upgrade', '--list', '--no-color'], callback);
      waitsFor('waiting for upgrade to complete', 600000, function() {
        return callback.callCount > 0;
      });
      return runs(function() {
        expect(console.log).toHaveBeenCalled();
        return expect(console.log.argsForCall[1][0]).toContain('empty');
      });
    });
    it("does display updates when the installed package's repository is not the same as the available package's repository", function() {
      var callback;
      fs.writeFileSync(path.join(packagesDir, 'different-repo', 'package.json'), JSON.stringify({
        name: 'different-repo',
        version: '0.3.0',
        repository: 'https://github.com/world/hello'
      }));
      callback = jasmine.createSpy('callback');
      apm.run(['upgrade', '--list', '--no-color'], callback);
      waitsFor('waiting for upgrade to complete', 600000, function() {
        return callback.callCount > 0;
      });
      return runs(function() {
        expect(console.log).toHaveBeenCalled();
        return expect(console.log.argsForCall[1][0]).toContain('different-repo 0.3.0 -> 0.4.0');
      });
    });
    it("allows the package names to upgrade to be specified", function() {
      var callback;
      fs.writeFileSync(path.join(packagesDir, 'multi-module', 'package.json'), JSON.stringify({
        name: 'multi-module',
        version: '0.1.0',
        repository: 'https://github.com/a/b'
      }));
      fs.writeFileSync(path.join(packagesDir, 'different-repo', 'package.json'), JSON.stringify({
        name: 'different-repo',
        version: '0.3.0',
        repository: 'https://github.com/world/hello'
      }));
      callback = jasmine.createSpy('callback');
      apm.run(['upgrade', '--list', '--no-color', 'different-repo'], callback);
      waitsFor('waiting for upgrade to complete', 600000, function() {
        return callback.callCount > 0;
      });
      return runs(function() {
        expect(console.log.callCount).toBe(2);
        expect(console.log.argsForCall[0][0]).not.toContain('multi-module 0.1.0 -> 0.3.0');
        expect(console.log.argsForCall[1][0]).toContain('different-repo 0.3.0 -> 0.4.0');
        return expect(console.log.argsForCall[1][0]).not.toContain('multi-module 0.1.0 -> 0.3.0');
      });
    });
    it("does not display updates when the installed package's repository does not exist", function() {
      var callback;
      fs.writeFileSync(path.join(packagesDir, 'different-repo', 'package.json'), JSON.stringify({
        name: 'different-repo',
        version: '0.3.0'
      }));
      callback = jasmine.createSpy('callback');
      apm.run(['upgrade', '--list', '--no-color'], callback);
      waitsFor('waiting for upgrade to complete', 600000, function() {
        return callback.callCount > 0;
      });
      return runs(function() {
        expect(console.log).toHaveBeenCalled();
        return expect(console.log.argsForCall[1][0]).toContain('empty');
      });
    });
    it("logs an error when the installed location of Atom cannot be found", function() {
      var callback;
      process.env.ATOM_RESOURCE_PATH = '/tmp/atom/is/not/installed/here';
      callback = jasmine.createSpy('callback');
      apm.run(['upgrade', '--list', '--no-color'], callback);
      waitsFor('waiting for upgrade to complete', 600000, function() {
        return callback.callCount > 0;
      });
      return runs(function() {
        expect(console.error).toHaveBeenCalled();
        return expect(console.error.argsForCall[0][0]).toContain('Could not determine current Atom version installed');
      });
    });
    it("ignores the commit SHA suffix in the version", function() {
      var callback;
      fs.writeFileSync(path.join(atomApp, 'package.json'), JSON.stringify({
        version: '0.10.0-deadbeef'
      }));
      fs.writeFileSync(path.join(packagesDir, 'multi-module', 'package.json'), JSON.stringify({
        name: 'multi-module',
        version: '0.1.0',
        repository: 'https://github.com/a/b'
      }));
      callback = jasmine.createSpy('callback');
      apm.run(['upgrade', '--list', '--no-color'], callback);
      waitsFor('waiting for upgrade to complete', 600000, function() {
        return callback.callCount > 0;
      });
      return runs(function() {
        expect(console.log).toHaveBeenCalled();
        return expect(console.log.argsForCall[1][0]).toContain('multi-module 0.1.0 -> 0.3.0');
      });
    });
    return describe("for outdated git packages", function() {
      var pkgJsonPath;
      pkgJsonPath = [][0];
      beforeEach(function() {
        var cloneUrl, gitRepo;
        delete process.env.ATOM_ELECTRON_URL;
        delete process.env.ATOM_PACKAGES_URL;
        process.env.ATOM_ELECTRON_VERSION = "0.22.0";
        gitRepo = path.join(__dirname, "fixtures", "test-git-repo.git");
        cloneUrl = "file://" + gitRepo;
        return apmRun(["install", cloneUrl], function() {
          var json;
          pkgJsonPath = path.join(process.env.ATOM_HOME, 'packages', 'test-git-repo', 'package.json');
          json = JSON.parse(fs.readFileSync(pkgJsonPath), 'utf8');
          json.apmInstallSource.sha = 'abcdef1234567890';
          return fs.writeFileSync(pkgJsonPath, JSON.stringify(json));
        });
      });
      it('shows an upgrade plan', function() {
        return apmRun(['upgrade', '--list', '--no-color'], function() {
          var text;
          text = console.log.argsForCall.map(function(arr) {
            return arr.join(' ');
          }).join("\n");
          return expect(text).toMatch(/Available \(1\).*\n.*test-git-repo abcdef12 -> 8ae43234/);
        });
      });
      return it('updates to the latest sha', function() {
        return apmRun(['upgrade', '-c', 'false', 'test-git-repo'], function() {
          var json;
          json = JSON.parse(fs.readFileSync(pkgJsonPath), 'utf8');
          return expect(json.apmInstallSource.sha).toBe('8ae432341ac6708aff9bb619eb015da14e9d0c0f');
        });
      });
    });
  });

}).call(this);
