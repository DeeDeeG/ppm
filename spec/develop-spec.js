// Generated by CoffeeScript 1.12.7
(function() {
  var apm, fs, path, temp;

  path = require('path');

  fs = require('fs-plus');

  temp = require('temp');

  apm = require('../lib/apm-cli');

  describe("apm develop", function() {
    var linkedRepoPath, ref, repoPath;
    ref = [], repoPath = ref[0], linkedRepoPath = ref[1];
    beforeEach(function() {
      var atomHome, atomReposHome;
      silenceOutput();
      spyOnToken();
      atomHome = temp.mkdirSync('apm-home-dir-');
      process.env.ATOM_HOME = atomHome;
      atomReposHome = temp.mkdirSync('apm-repos-home-dir-');
      process.env.ATOM_REPOS_HOME = atomReposHome;
      repoPath = path.join(atomReposHome, 'fake-package');
      return linkedRepoPath = path.join(atomHome, 'dev', 'packages', 'fake-package');
    });
    describe("when the package doesn't have a published repository url", function() {
      return it("logs an error", function() {
        var Develop, callback;
        Develop = require('../lib/develop');
        spyOn(Develop.prototype, "getRepositoryUrl").andCallFake(function(packageName, callback) {
          return callback("Here is the error");
        });
        callback = jasmine.createSpy('callback');
        apm.run(['develop', "fake-package"], callback);
        waitsFor('waiting for develop to complete', function() {
          return callback.callCount === 1;
        });
        return runs(function() {
          expect(callback.mostRecentCall.args[0]).toBe("Here is the error");
          expect(fs.existsSync(repoPath)).toBeFalsy();
          return expect(fs.existsSync(linkedRepoPath)).toBeFalsy();
        });
      });
    });
    describe("when the repository hasn't been cloned", function() {
      return it("clones the repository to ATOM_REPOS_HOME and links it to ATOM_HOME/dev/packages", function() {
        var Develop, callback;
        Develop = require('../lib/develop');
        spyOn(Develop.prototype, "getRepositoryUrl").andCallFake(function(packageName, callback) {
          var repoUrl;
          repoUrl = path.join(__dirname, 'fixtures', 'repo.git');
          return callback(null, repoUrl);
        });
        spyOn(Develop.prototype, "installDependencies").andCallFake(function(packageDirectory, options) {
          return this.linkPackage(packageDirectory, options);
        });
        callback = jasmine.createSpy('callback');
        apm.run(['develop', "fake-package"], callback);
        waitsFor('waiting for develop to complete', function() {
          return callback.callCount === 1;
        });
        return runs(function() {
          expect(callback.mostRecentCall.args[0]).toBeFalsy();
          expect(fs.existsSync(repoPath)).toBeTruthy();
          expect(fs.existsSync(path.join(repoPath, 'Syntaxes', 'Makefile.plist'))).toBeTruthy();
          expect(fs.existsSync(linkedRepoPath)).toBeTruthy();
          return expect(fs.realpathSync(linkedRepoPath)).toBe(fs.realpathSync(repoPath));
        });
      });
    });
    return describe("when the repository has already been cloned", function() {
      return it("links it to ATOM_HOME/dev/packages", function() {
        var callback;
        fs.makeTreeSync(repoPath);
        fs.writeFileSync(path.join(repoPath, "package.json"), "");
        callback = jasmine.createSpy('callback');
        apm.run(['develop', "fake-package"], callback);
        waitsFor('waiting for develop to complete', function() {
          return callback.callCount === 1;
        });
        return runs(function() {
          expect(callback.mostRecentCall.args[0]).toBeFalsy();
          expect(fs.existsSync(repoPath)).toBeTruthy();
          expect(fs.existsSync(linkedRepoPath)).toBeTruthy();
          return expect(fs.realpathSync(linkedRepoPath)).toBe(fs.realpathSync(repoPath));
        });
      });
    });
  });

}).call(this);
