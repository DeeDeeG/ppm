// Generated by CoffeeScript 1.12.7
(function() {
  var Unpublish, apm, express, http, temp,
    slice = [].slice;

  express = require('express');

  http = require('http');

  temp = require('temp');

  apm = require('../lib/apm-cli');

  Unpublish = require('../lib/unpublish');

  describe('apm unpublish', function() {
    var ref, server, unpublishPackageCallback, unpublishVersionCallback;
    ref = [], server = ref[0], unpublishPackageCallback = ref[1], unpublishVersionCallback = ref[2];
    beforeEach(function() {
      var app, live;
      silenceOutput();
      spyOnToken();
      unpublishPackageCallback = jasmine.createSpy('unpublishPackageCallback');
      unpublishVersionCallback = jasmine.createSpy('unpublishVersionCallback');
      app = express();
      app["delete"]('/packages/test-package', function(request, response) {
        unpublishPackageCallback();
        return response.status(204).send(204);
      });
      app["delete"]('/packages/test-package/versions/1.0.0', function(request, response) {
        unpublishVersionCallback();
        return response.status(204).send(204);
      });
      server = http.createServer(app);
      live = false;
      server.listen(3000, '127.0.0.1', function() {
        process.env.ATOM_HOME = temp.mkdirSync('apm-home-dir-');
        process.env.ATOM_API_URL = "http://localhost:3000";
        return live = true;
      });
      return waitsFor(function() {
        return live;
      });
    });
    afterEach(function() {
      var done;
      done = false;
      server.close(function() {
        return done = true;
      });
      return waitsFor(function() {
        return done;
      });
    });
    describe("when no version is specified", function() {
      it('unpublishes the package', function() {
        var callback;
        callback = jasmine.createSpy('callback');
        apm.run(['unpublish', '--force', 'test-package'], callback);
        waitsFor('waiting for unpublish command to complete', function() {
          return callback.callCount > 0;
        });
        return runs(function() {
          expect(callback.argsForCall[0][0]).toBeUndefined();
          expect(unpublishPackageCallback.callCount).toBe(1);
          return expect(unpublishVersionCallback.callCount).toBe(0);
        });
      });
      describe("when --force is not specified", function() {
        it('prompts to unpublish ALL versions', function() {
          var callback;
          callback = jasmine.createSpy('callback');
          spyOn(Unpublish.prototype, 'prompt');
          apm.run(['unpublish', 'test-package'], callback);
          return waitsFor('waiting for prompt to be called', function() {
            return Unpublish.prototype.prompt.argsForCall[0][0].match(/unpublish ALL VERSIONS of 'test-package'.*irreversible/);
          });
        });
        return describe('when the user accepts the default answer', function() {
          return it('does not unpublish the package', function() {
            var callback;
            callback = jasmine.createSpy('callback');
            spyOn(Unpublish.prototype, 'prompt').andCallFake(function() {
              var args, cb, i;
              args = 2 <= arguments.length ? slice.call(arguments, 0, i = arguments.length - 1) : (i = 0, []), cb = arguments[i++];
              return cb('');
            });
            spyOn(Unpublish.prototype, 'unpublishPackage');
            apm.run(['unpublish', 'test-package'], callback);
            waitsFor('waiting for unpublish command to complete', function() {
              return callback.callCount > 0;
            });
            return runs(function() {
              expect(Unpublish.prototype.unpublishPackage).not.toHaveBeenCalled();
              return expect(callback.argsForCall[0][0]).toMatch(/Cancelled/);
            });
          });
        });
      });
      return describe("when the package does not exist", function() {
        return it("calls back with an error", function() {
          var callback;
          callback = jasmine.createSpy('callback');
          apm.run(['unpublish', '--force', 'not-a-package'], callback);
          waitsFor('waiting for unpublish command to complete', function() {
            return callback.callCount > 0;
          });
          return runs(function() {
            expect(callback.argsForCall[0][0]).not.toBeUndefined();
            expect(unpublishPackageCallback.callCount).toBe(0);
            return expect(unpublishVersionCallback.callCount).toBe(0);
          });
        });
      });
    });
    return describe("when a version is specified", function() {
      it('unpublishes the version', function() {
        var callback;
        callback = jasmine.createSpy('callback');
        apm.run(['unpublish', '--force', 'test-package@1.0.0'], callback);
        waitsFor('waiting for unpublish command to complete', function() {
          return callback.callCount > 0;
        });
        return runs(function() {
          expect(callback.argsForCall[0][0]).toBeUndefined();
          expect(unpublishPackageCallback.callCount).toBe(0);
          return expect(unpublishVersionCallback.callCount).toBe(1);
        });
      });
      describe("when --force is not specified", function() {
        it('prompts to unpublish that version', function() {
          var callback;
          callback = jasmine.createSpy('callback');
          spyOn(Unpublish.prototype, 'prompt');
          apm.run(['unpublish', 'test-package@1.0.0'], callback);
          return waitsFor('waiting for prompt to be called', function() {
            return Unpublish.prototype.prompt.argsForCall[0][0].match(/unpublish 'test-package@1.0.0'/);
          });
        });
        return describe('when the user accepts the default answer', function() {
          return it('does not unpublish the package', function() {
            var callback;
            callback = jasmine.createSpy('callback');
            spyOn(Unpublish.prototype, 'prompt').andCallFake(function() {
              var args, cb, i;
              args = 2 <= arguments.length ? slice.call(arguments, 0, i = arguments.length - 1) : (i = 0, []), cb = arguments[i++];
              return cb('');
            });
            spyOn(Unpublish.prototype, 'unpublishPackage');
            apm.run(['unpublish', 'test-package'], callback);
            waitsFor('waiting for unpublish command to complete', function() {
              return callback.callCount > 0;
            });
            return runs(function() {
              expect(Unpublish.prototype.unpublishPackage).not.toHaveBeenCalled();
              return expect(callback.argsForCall[0][0]).toMatch(/Cancelled/);
            });
          });
        });
      });
      return describe("when the version does not exist", function() {
        return it("calls back with an error", function() {
          var callback;
          callback = jasmine.createSpy('callback');
          apm.run(['unpublish', '--force', 'test-package@2.0.0'], callback);
          waitsFor('waiting for unpublish command to complete', function() {
            return callback.callCount > 0;
          });
          return runs(function() {
            expect(callback.argsForCall[0][0]).not.toBeUndefined();
            expect(unpublishPackageCallback.callCount).toBe(0);
            return expect(unpublishVersionCallback.callCount).toBe(0);
          });
        });
      });
    });
  });

}).call(this);
