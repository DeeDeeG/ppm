// Generated by CoffeeScript 1.12.7
(function() {
  var apm, fs, path, temp;

  fs = require('fs');

  path = require('path');

  temp = require('temp');

  apm = require('../lib/apm-cli');

  describe('apm link/unlink', function() {
    beforeEach(function() {
      silenceOutput();
      return spyOnToken();
    });
    describe("when the dev flag is false (the default)", function() {
      return it('symlinks packages to $ATOM_HOME/packages', function() {
        var atomHome, callback, packageToLink;
        atomHome = temp.mkdirSync('apm-home-dir-');
        process.env.ATOM_HOME = atomHome;
        packageToLink = temp.mkdirSync('a-package-');
        process.chdir(packageToLink);
        callback = jasmine.createSpy('callback');
        runs(function() {
          return apm.run(['link'], callback);
        });
        waitsFor('waiting for link to complete', function() {
          return callback.callCount > 0;
        });
        runs(function() {
          expect(fs.existsSync(path.join(atomHome, 'packages', path.basename(packageToLink)))).toBeTruthy();
          expect(fs.realpathSync(path.join(atomHome, 'packages', path.basename(packageToLink)))).toBe(fs.realpathSync(packageToLink));
          callback.reset();
          return apm.run(['unlink'], callback);
        });
        waitsFor('waiting for unlink to complete', function() {
          return callback.callCount > 0;
        });
        return runs(function() {
          return expect(fs.existsSync(path.join(atomHome, 'packages', path.basename(packageToLink)))).toBeFalsy();
        });
      });
    });
    describe("when the dev flag is true", function() {
      return it('symlinks packages to $ATOM_HOME/dev/packages', function() {
        var atomHome, callback, packageToLink;
        atomHome = temp.mkdirSync('apm-home-dir-');
        process.env.ATOM_HOME = atomHome;
        packageToLink = temp.mkdirSync('a-package-');
        process.chdir(packageToLink);
        callback = jasmine.createSpy('callback');
        runs(function() {
          return apm.run(['link', '--dev'], callback);
        });
        waitsFor('waiting for link to complete', function() {
          return callback.callCount > 0;
        });
        runs(function() {
          expect(fs.existsSync(path.join(atomHome, 'dev', 'packages', path.basename(packageToLink)))).toBeTruthy();
          expect(fs.realpathSync(path.join(atomHome, 'dev', 'packages', path.basename(packageToLink)))).toBe(fs.realpathSync(packageToLink));
          callback.reset();
          return apm.run(['unlink', '--dev'], callback);
        });
        waitsFor('waiting for unlink to complete', function() {
          return callback.callCount > 0;
        });
        return runs(function() {
          return expect(fs.existsSync(path.join(atomHome, 'dev', 'packages', path.basename(packageToLink)))).toBeFalsy();
        });
      });
    });
    describe("when the hard flag is true", function() {
      return it("unlinks the package from both $ATOM_HOME/packages and $ATOM_HOME/dev/packages", function() {
        var atomHome, callback, packageToLink;
        atomHome = temp.mkdirSync('apm-home-dir-');
        process.env.ATOM_HOME = atomHome;
        packageToLink = temp.mkdirSync('a-package-');
        process.chdir(packageToLink);
        callback = jasmine.createSpy('callback');
        runs(function() {
          return apm.run(['link', '--dev'], callback);
        });
        waitsFor('link --dev to complete', function() {
          return callback.callCount === 1;
        });
        runs(function() {
          return apm.run(['link'], callback);
        });
        waitsFor('link to complete', function() {
          return callback.callCount === 2;
        });
        runs(function() {
          return apm.run(['unlink', '--hard'], callback);
        });
        waitsFor('unlink --hard to complete', function() {
          return callback.callCount === 3;
        });
        return runs(function() {
          expect(fs.existsSync(path.join(atomHome, 'dev', 'packages', path.basename(packageToLink)))).toBeFalsy();
          return expect(fs.existsSync(path.join(atomHome, 'packages', path.basename(packageToLink)))).toBeFalsy();
        });
      });
    });
    describe("when the all flag is true", function() {
      return it("unlinks all packages in $ATOM_HOME/packages and $ATOM_HOME/dev/packages", function() {
        var atomHome, callback, packageToLink1, packageToLink2, packageToLink3;
        atomHome = temp.mkdirSync('apm-home-dir-');
        process.env.ATOM_HOME = atomHome;
        packageToLink1 = temp.mkdirSync('a-package-');
        packageToLink2 = temp.mkdirSync('a-package-');
        packageToLink3 = temp.mkdirSync('a-package-');
        callback = jasmine.createSpy('callback');
        runs(function() {
          return apm.run(['link', '--dev', packageToLink1], callback);
        });
        waitsFor('link --dev to complete', function() {
          return callback.callCount === 1;
        });
        runs(function() {
          callback.reset();
          apm.run(['link', packageToLink2], callback);
          return apm.run(['link', packageToLink3], callback);
        });
        waitsFor('link to complee', function() {
          return callback.callCount === 2;
        });
        runs(function() {
          callback.reset();
          expect(fs.existsSync(path.join(atomHome, 'dev', 'packages', path.basename(packageToLink1)))).toBeTruthy();
          expect(fs.existsSync(path.join(atomHome, 'packages', path.basename(packageToLink2)))).toBeTruthy();
          expect(fs.existsSync(path.join(atomHome, 'packages', path.basename(packageToLink3)))).toBeTruthy();
          return apm.run(['unlink', '--all'], callback);
        });
        waitsFor('unlink --all to complete', function() {
          return callback.callCount === 1;
        });
        return runs(function() {
          expect(fs.existsSync(path.join(atomHome, 'dev', 'packages', path.basename(packageToLink1)))).toBeFalsy();
          expect(fs.existsSync(path.join(atomHome, 'packages', path.basename(packageToLink2)))).toBeFalsy();
          return expect(fs.existsSync(path.join(atomHome, 'packages', path.basename(packageToLink3)))).toBeFalsy();
        });
      });
    });
    describe("when the package name is numeric", function() {
      return it("still links and unlinks normally", function() {
        var atomHome, callback, numericPackageName;
        atomHome = temp.mkdirSync('apm-home-dir-');
        process.env.ATOM_HOME = atomHome;
        numericPackageName = temp.mkdirSync('42');
        callback = jasmine.createSpy('callback');
        runs(function() {
          return apm.run(['link', numericPackageName], callback);
        });
        waitsFor('link to complete', function() {
          return callback.callCount === 1;
        });
        runs(function() {
          expect(fs.existsSync(path.join(atomHome, 'packages', path.basename(numericPackageName)))).toBeTruthy();
          expect(fs.realpathSync(path.join(atomHome, 'packages', path.basename(numericPackageName)))).toBe(fs.realpathSync(numericPackageName));
          callback.reset();
          return apm.run(['unlink', numericPackageName], callback);
        });
        waitsFor('unlink to complete', function() {
          return callback.callCount === 1;
        });
        return runs(function() {
          return expect(fs.existsSync(path.join(atomHome, 'packages', path.basename(numericPackageName)))).toBeFalsy();
        });
      });
    });
    describe("when the package name is set after --name", function() {
      return it("still links and unlinks normally", function() {
        var atomHome, callback, packageName, packagePath;
        atomHome = temp.mkdirSync('apm-home-dir-');
        process.env.ATOM_HOME = atomHome;
        packagePath = temp.mkdirSync('new-package');
        packageName = 'new-package-name';
        callback = jasmine.createSpy('callback');
        runs(function() {
          return apm.run(['link', packagePath, '--name', packageName], callback);
        });
        waitsFor('link to complete', function() {
          return callback.callCount === 1;
        });
        runs(function() {
          expect(fs.existsSync(path.join(atomHome, 'packages', packageName))).toBeTruthy();
          expect(fs.realpathSync(path.join(atomHome, 'packages', packageName))).toBe(fs.realpathSync(packagePath));
          callback.reset();
          return apm.run(['unlink', packageName], callback);
        });
        waitsFor('unlink to complete', function() {
          return callback.callCount === 1;
        });
        return runs(function() {
          return expect(fs.existsSync(path.join(atomHome, 'packages', packageName))).toBeFalsy();
        });
      });
    });
    describe("when unlinking a path that is not a symbolic link", function() {
      return it("logs an error and exits", function() {
        var callback;
        callback = jasmine.createSpy('callback');
        process.chdir(temp.mkdirSync('not-a-symlink'));
        apm.run(['unlink'], callback);
        waitsFor('waiting for command to complete', function() {
          return callback.callCount > 0;
        });
        return runs(function() {
          expect(console.error.mostRecentCall.args[0].length).toBeGreaterThan(0);
          return expect(callback.mostRecentCall.args[0]).not.toBeUndefined();
        });
      });
    });
    return describe("when unlinking a path that does not exist", function() {
      return it("logs an error and exits", function() {
        var callback;
        callback = jasmine.createSpy('callback');
        apm.run(['unlink', 'a-path-that-does-not-exist'], callback);
        waitsFor('waiting for command to complete', function() {
          return callback.callCount > 0;
        });
        return runs(function() {
          expect(console.error.mostRecentCall.args[0].length).toBeGreaterThan(0);
          return expect(callback.mostRecentCall.args[0]).not.toBeUndefined();
        });
      });
    });
  });

}).call(this);
